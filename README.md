# Advent of Code 2025

Fortran 77 on RaspberryPiOS (Debian trixie)

Use (with gfortran installed) f77 filename.f -o filename to compile and link.

## Notes

**Day 1** Part 1 is straightforward - we can ignore what the safe's dial should actually read and use MOD - it all comes out in the wash. Part 2 was less straightforward as we do need to care what the dial reads! I also put a check in for moving the dial from 0 to 0 (it doesn't count as a click through or to zero) - but my puzzle data didn't have this edge case in it. I've left my debugging WRITE(\*,\*) statements in the code as it illustrates my logic nicely. I suspect there's some further refinement possible, but it works (and quickly).

**Day 2** Reuses a variant of a string to integer routine I wrote last year (I could have delved into Fortran 90 for CSV handling, but toughed it out in f77). Happy with the maths I used to find the invalid product ids for part 1, even if it is a little brute-force at the end. I bet all those people who are using languages that can deal with ranges are much happier than I am today! I then simplified the code in part 1 (day2-1a.f) although it runs much more slowly - around 0.2s vs around 0.03s on my Pi4B as a basis for part 2. Part 2 takes a long-ish time to run - around 28s - and there will definitely optimisations that can be done, even in Fortran 77. But, I understand how it works, so that's good enough for today. Just looked at the code again and there were a couple of obvious optimisations by moving a couple of assignments outside of loops. Run time for day2-2a.f is now around 20s.  

**Day 3** Straightforward stuff today. Part 1 completed before I went out shopping, part 2 after I came home. Part 2 also answers part 1, as the code for part 1 is simple to generalise by adding another loop in the function to calculate the maximum number of jolts that a battery bank can deliver from N batteries. The only slightly tricky thing was remembering to convert the CALCJOLTS calculation to use integer*8's correctly. Part 1 takes 0.016s on the Pi4, part 2 (generating both answers) takes 0.018s. Probably not much left to optimise in the part 2 solution.

**Day 4** A nice grid problem with a similar (but simpler) test to that used by Conway's life. I converted the character input to a 2D array of 0s and 1s, adding a border of 0s to the input to simplify the test at the grid edges. I managed to write the correct code for part 1 some time before I got the correct answer as I'd managed to corrupt my puzzle input courtesy of finger trouble in vi! Once I'd solved part 1, part 2 took another 14 minutes to complete including testing with the sample input to make absolutely sure my approach was correct. The algorithm I've used is faster at converging on the solution than the example provided in the puzzle text for part 2 as there's nothing to stop you immediately removing a roll (which may mean that the neighbouring roll(s) can be removed during the current iteration). The sample input only takes 3 iterations to solve using my approach rather than the 10 suggested in the example. On the Pi4B part 1 takes 0.01s, part 2 0.03s.

**Day 5** A day when you *almost* wish that Fortran77 had a range abstraction, as well as recursion. Having said that, part 1 was straightforward without either. Part 2 had me stumped for a little while until I realised that there were 4 (rather than 3) different conditions I needed to check for while iterating through the starting ranges to find the minimum set of ranges that covered all of the fresh product IDs. I started off checking if I could extend a range to either the left or the right, and that if the range was a subset of a consolidated range. I'd forgotten that I also needed to check if I could replace my consolidated range with another that happened to be a superset. Once I'd factored that in, my iterative solution worked nicely. On a Pi4B part 1 takes 0.025s, part 2 0.038s. I've left the debugging WRITE(\*,\*) statements as comments in the code as they illustrate my logic nicely.

**Day 6** The biggest difficulty, certainly for part 2, was parsing and manipulating the input. However, part 1 allowed me to use list-directed i/o which made input parsing straightforward for once. Fortran77 bliss! Part 2 was decidedly nastier, so I went back to reading the puzzle input into character strings and then manipulating it. Yuk. Just to make things trickier, there's some nasty stuff to handle that only shows up in the puzzle data - e.g. we're not guaranteed to have a fixed quantity of numbers to add/multiply for each problem. Hence the incredibly ugly 'get out of this loop NOW!' code I wrote on line 84 of day6-2.f. Because of this, the multiply code I wrote for part 1 needed a zero check adding to it for part 2. And, of course, I didn't bother writing any subroutines or functions to make the code more readable. Sigh. Definitely an ugly day all around, so I'm not very proud of this code. However, it does work - part 1 in 0.011s, part 2 in 0.025s on my PI4B. Tomorrow is another day.

**Day 7** Feeling smug as I found a way to do this that didn't require recursion (or a grid), so I still have a 100% record of sticking within the Fortran77 standard. I also found a use for complex numbers for the first time this year, but on reflection probably didn't really need them. Oh well. Part 1 didn't take me too long to finish. I kept a count of the activated splitters and an array of each unique column in the grid that a beam was on after splitting (or not splitting), so that I could process the beam(s) in the next row but one. The way the puzzle input was formatted meant that every other row could be skipped, as a beam can't be split if there are no splitters. I managed to complete part 1 before breakfast. Returing to part 2 after lunch meant that I began to regret not going for recursion after all, until I got my trusty pen and paper out. I worked out that the simplest way to calculate the number of timelines was to keep a track on each row of the grid how many times a beam had been found on each column. When this is the value held 'above' a splitter (starting with 1 at S), it's added to each of the columns to the left and right of the splitter. The value of the column that the splitter was in is then zeroed to avoid overcounting. I was somewhat surprised how large the answer was - so much so I needed to use Integer * 8's - which I hadn't done at first. Fortunately the number that was spat out of my first attempt was so large (but too small) that I was suspicious ... My part 2 solution also calculates part 1 and runs in the same time (0.08s on a Pi4B) as the part 1 solution alone. There are some minor optimisations that I haven't done (e.g. the naive way the co-ordinates of the splitters are held and subsequently searched through could be improved) but it's Sunday and I have other things to do.
