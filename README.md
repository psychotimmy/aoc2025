# Advent of Code 2025

Fortran 77 (mostly) on RaspberryPiOS (Debian trixie)

Use (with gfortran installed) f77 (-O3) filename.f -o filename to compile and link. (The -O3 flag was used on days 8 and 9 to reduce the amount of time my horrible insertion sort code takes to run!).

Day 10, part 1 uses bitwise XOR and a recursive subroutine, so f90 territory, albeit written to look like f77. Day 10 part 2 reuses the recursive subroutine, adds in another one and uses bitwise AND for good measure.
Day 11 parts 1 and 2 also resort to recursion.

## Notes

**Day 1** Part 1 is straightforward - we can ignore what the safe's dial should actually read and use MOD - it all comes out in the wash. Part 2 was less straightforward as we do need to care what the dial reads! I also put a check in for moving the dial from 0 to 0 (it doesn't count as a click through or to zero) - but my puzzle data didn't have this edge case in it. I've left my debugging WRITE(\*,\*) statements in the code as it illustrates my logic nicely. I suspect there's some further refinement possible, but it works (and quickly).

**Day 2** Reuses a variant of a string to integer routine I wrote last year (I could have delved into Fortran 90 for CSV handling, but toughed it out in f77). Happy with the maths I used to find the invalid product ids for part 1, even if it is a little brute-force at the end. I bet all those people who are using languages that can deal with ranges are much happier than I am today! I then simplified the code in part 1 (day2-1a.f) although it runs much more slowly - around 0.2s vs around 0.03s on my Pi4B as a basis for part 2. Part 2 takes a long-ish time to run - around 28s - and there will definitely optimisations that can be done, even in Fortran 77. But, I understand how it works, so that's good enough for today. Just looked at the code again and there were a couple of obvious optimisations by moving a couple of assignments outside of loops. Run time for day2-2a.f is now around 20s.  

**Day 3** Straightforward stuff today. Part 1 completed before I went out shopping, part 2 after I came home. Part 2 also answers part 1, as the code for part 1 is simple to generalise by adding another loop in the function to calculate the maximum number of jolts that a battery bank can deliver from N batteries. The only slightly tricky thing was remembering to convert the CALCJOLTS calculation to use integer*8's correctly. Part 1 takes 0.016s on the Pi4, part 2 (generating both answers) takes 0.018s. Probably not much left to optimise in the part 2 solution.

**Day 4** A nice grid problem with a similar (but simpler) test to that used by Conway's life. I converted the character input to a 2D array of 0s and 1s, adding a border of 0s to the input to simplify the test at the grid edges. I managed to write the correct code for part 1 some time before I got the correct answer as I'd managed to corrupt my puzzle input courtesy of finger trouble in vi! Once I'd solved part 1, part 2 took another 14 minutes to complete including testing with the sample input to make absolutely sure my approach was correct. The algorithm I've used is faster at converging on the solution than the example provided in the puzzle text for part 2 as there's nothing to stop you immediately removing a roll (which may mean that the neighbouring roll(s) can be removed during the current iteration). The sample input only takes 3 iterations to solve using my approach rather than the 10 suggested in the example. On the Pi4B part 1 takes 0.01s, part 2 0.03s.

**Day 5** A day when you *almost* wish that Fortran77 had a range abstraction, as well as recursion. Having said that, part 1 was straightforward without either. Part 2 had me stumped for a little while until I realised that there were 4 (rather than 3) different conditions I needed to check for while iterating through the starting ranges to find the minimum set of ranges that covered all of the fresh product IDs. I started off checking if I could extend a range to either the left or the right, and that if the range was a subset of a consolidated range. I'd forgotten that I also needed to check if I could replace my consolidated range with another that happened to be a superset. Once I'd factored that in, my iterative solution worked nicely. On a Pi4B part 1 takes 0.025s, part 2 0.038s. I've left the debugging WRITE(\*,\*) statements as comments in the code as they illustrate my logic nicely.

**Day 6** The biggest difficulty, certainly for part 2, was parsing and manipulating the input. However, part 1 allowed me to use list-directed i/o which made input parsing straightforward for once. Fortran77 bliss! Part 2 was decidedly nastier, so I went back to reading the puzzle input into character strings and then manipulating it. Yuk. Just to make things trickier, there's some nasty stuff to handle that only shows up in the puzzle data - e.g. we're not guaranteed to have a fixed quantity of numbers to add/multiply for each problem. Hence the incredibly ugly 'get out of this loop NOW!' code I wrote on line 84 of day6-2.f. Because of this, the multiply code I wrote for part 1 needed a zero check adding to it for part 2. And, of course, I didn't bother writing any subroutines or functions to make the code more readable. Sigh. Definitely an ugly day all around, so I'm not very proud of this code. However, it does work - part 1 in 0.011s, part 2 in 0.025s on my PI4B. Tomorrow is another day.

**Day 7** Feeling smug as I found a way to do this that didn't require recursion (or a grid), so I still have a 100% record of sticking within the Fortran77 standard. I also found a use for complex numbers for the first time this year, but on reflection probably didn't really need them. Oh well. Part 1 didn't take me too long to finish. I kept a count of the activated splitters and an array of each unique column in the grid that a beam was on after splitting (or not splitting), so that I could process the beam(s) in the next row but one. The way the puzzle input was formatted meant that every other row could be skipped, as a beam can't be split if there are no splitters. I managed to complete part 1 before breakfast. Returning to part 2 after lunch meant that I began to regret not going for recursion after all, until I got my trusty pen and paper out. I worked out that the simplest way to calculate the number of timelines was to keep a track on each row of the grid how many times a beam had been found on each column. When this is the value held 'above' a splitter (starting with 1 at S), it's added to each of the columns to the left and right of the splitter. The value of the column that the splitter was in is then zeroed to avoid over-counting. I was somewhat surprised how large the answer was - so much so I needed to use Integer * 8's - which I hadn't done at first. Fortunately the number that was spat out of my first attempt was so large (but too small) that I was suspicious ... My part 2 solution also calculates part 1 and runs in the same time (0.08s on a Pi4B) as the part 1 solution alone. There are some minor optimisations that I haven't done (e.g. the naive way the co-ordinates of the splitters are held and subsequently searched through could be improved) but it's Sunday and I have other things to do.

**Day 8** Ouch. Took ages to complete part 1. It's at times like these I wish I was using a language with intrinsic sorting, grouping, tuples, sets etc. etc. Somehow I struggled through it using a reliable but hugely inefficient insertion sort I wrote last year (sorting up to 0.5m items on a Pi4B using it takes ... ages, unsurprisingly). The grouping is a "masterclass" in nested loops - five deep at one point (six if you count a debugging loop that can be removed). The right answer does appear, however! 348s on my Pi4B, 70 seconds on my Pi5 (this is *with* the -O3 compiler flag). About 98% of the runtime is the insertion sort - writing a better sorting algorithm in Fortran77 is a project for after 12th December. Actually, just about *every* sorting algorithm is better than insertion sort! Part 2 took much longer than it should have done as it's relatively simple. What I couldn't do (until I took a couple of long walks) was work out the X co-ordinates of the two pairs ... if you look towards the bottom of the main program you might see why. Sometimes multiple arrays of complex numbers aren't that friendly - even in f77 there are better ways of organising the data. For the puzzle input, starting at 1,000 pairs of junction boxes and finding the first group where we end up with 1 circuit containing all 1,000 junction boxes takes a while ... mostly due to the insertion sort yet again. On my Pi5 part 2 runs in 5 minutes and 12 seconds, on the Pi4B it takes a mere 15 minutes and 43 seconds!!

**Day 9** Part 1 was simple, once I realised that the area includes the boundary of the shape. The Pi4B runs this in 0.017s, most of which is spent reading the input from the SD card. Part 2 (incorporating part 1) sorts the rectangles into size order from largest to smallest (I really need to write a better F77 sort than insertion sort!!), checks that the large polygon has exactly 0 or 2 corners on each row and column of the grid (this holds true for the sample data and my puzzle data) and then creates 2 lists of vertical boundaries and horizontal boundaries. Finally we check each rectangle against these lists. If a rectangle has no boundaries that intrude into it's interior then the rectangle is contained entirely within the boundaries of the large polygon. If one or more boundaries encroach, then it's no good. A nasty little bug held me up for ages (I took several detours into raycasting and goodness knows what else) but my original algorithm was correct all along (well, it would have been, if I hadn't managed to introduce a maddening little bug into it). With the insertion sort still in place, plus a chunk of debugging output, part 2 take the Pi4B 88 seconds to run.

**Day 10** Part 1 is the first puzzle I've used recursion to solve, so we've finally strayed into Fortran 90 territory. I don't think the bitwise XOR intrinsic function is 100% f77 standard as well, although a lot of compliers (for example, Sun's) 'back in the day' supported it. It's just too painful to use nested do loops and gotos with my own stack to keep within the f77 standard. The main 'ah ha!' moment was realising that it's not worth pressing a button more than once as it won't change the outcome of a particular combination of buttons. Hence the ability to use (binary) numbers and XOR to check the machine lights against the target state. Part 1 runs in 0.04s on the Pi4B. Part 2 was the last puzzle I completed in 2025. The algorithm used is explained in detail in the comments. Simply put it works backwards from the joltage requirements to zero, using recursion to continually halve the amount of work required to iterate through candidates of button combinations. I'd written the code assuming that at least one joltage in each set would be odd, and, of course, one of my puzzle inputs had nothing but even joltages. Fortunately it wasn't too difficult to hack around that problem (it's ugly, but then so is much of the rest of the code) so I got day 10's second star. Overall it took several days of thinking through and playing around with ideas about how to solve the puzzle without resorting to maths, 3rd party libraries or looking up spoilers. I wrote a number of pieces of code that don't quite work testifying to this! There are some obvious optimisations to make in the recursions (e.g. caching partial answers and combinations) but as it runs in around 18s on the Pi4B I'm happy enough just to get the answer in a way that I understand!

**Day 11** Part 1 was about creating a graph (the input is nicely formatted to parse and store as (complex) numbers) and then walking the graph to find the number of paths from the start node to the exit node. Calling on recursion again (so using an F90 extension) made the task a straightforward depth-first search. It runs on the Pi4B in 0.023s - it would take less time if I wasn't doing a complex number to array index lookup everytime I moved from one node to another. I chose to use complex numbers in anticipation of a part 2 that wasn't the actual part 2 that appeared. Oh well. Part 2 *could* be solved with the code from part 1, but I'm not prepared to wait until the heat death of the universe to get the answer. I refactored my depth-first search subroutine into a function for part 2 and included a cache of the results we'd already seen. I think the cool kids call this 'memoization', but that's a horrible made-up word I hate seeing used. There's still inefficiency in my solution from the data storage decision I made for part 1, but them's the breaks. Part 2 runs in 0.029s on the Pi4B.

**Day 12** Pure dumb luck involved in finding this solution! I'd intended my code as a first pass, but tried the answer anyway and what do you know ... we don't have to solve a generalised NP-complete problem on the last day ;) 
